'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author Pedro Sanders
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @since v1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _utils = require('core/processor/utils');

var _utils2 = _interopRequireDefault(_utils);

var _ip_util = require('core/ip_util');

var _ip_util2 = _interopRequireDefault(_ip_util);

var _context = require('core/context');

var _context2 = _interopRequireDefault(_context);

var _config_util = require('core/config_util');

var _config_util2 = _interopRequireDefault(_config_util);

var _status = require('core/status');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SipFactory = Packages.javax.sip.SipFactory;
var Request = Packages.javax.sip.message.Request;
var Response = Packages.javax.sip.message.Response;
var RouteHeader = Packages.javax.sip.header.RouteHeader;
var CSeqHeader = Packages.javax.sip.header.CSeqHeader;
var ViaHeader = Packages.javax.sip.header.ViaHeader;
var MaxForwardsHeader = Packages.javax.sip.header.MaxForwardsHeader;
var LogManager = Packages.org.apache.logging.log4j.LogManager;
var LOG = LogManager.getLogger();

var RequestHandler = function () {
    function RequestHandler(locator, sipProvider, dataAPIs, contextStorage) {
        _classCallCheck(this, RequestHandler);

        this.sipProvider = sipProvider;
        this.locator = locator;
        this.contextStorage = contextStorage;
        this.messageFactory = SipFactory.getInstance().createMessageFactory();
        this.headerFactory = SipFactory.getInstance().createHeaderFactory();
        this.addressFactory = SipFactory.getInstance().createAddressFactory();
        this.config = (0, _config_util2.default)();
        this.ipUtil = new _ip_util2.default((0, _config_util2.default)());
    }

    _createClass(RequestHandler, [{
        key: 'doProcess',
        value: function doProcess(request, serverTransaction) {
            var _this = this;

            var procUtils = new _utils2.default(request, serverTransaction, this.messageFactory);
            var response = this.locator.findEndpoint(_utils2.default.getAOR(request));

            if (response.status == _status.Status.NOT_FOUND) {
                return procUtils.sendResponse(Response.TEMPORARILY_UNAVAILABLE);
            }

            // Call forking
            response.result.forEach(function (route) {
                return _this.processRoute(request, serverTransaction, route);
            });
        }
    }, {
        key: 'processRoute',
        value: function processRoute(requestIn, serverTransaction, route) {
            var requestOut = requestIn.clone();
            var transport = requestIn.getHeader(ViaHeader.NAME).getTransport().toLowerCase();
            var lp = this.sipProvider.getListeningPoint(transport);
            var localAddr = { host: lp.getIPAddress().toString(), port: lp.getPort() };
            var advertisedAddr = this.getAdvertizedAddr(route, localAddr, this.config.spec.externAddr);

            LOG.debug('advertised addr: ' + JSON.stringify(advertisedAddr));
            LOG.debug('flow: ' + JSON.stringify(route));

            this.configureGeneral(requestOut, route, advertisedAddr);

            if (this.proxyOwnsRequest(requestOut, localAddr, advertisedAddr)) {
                requestOut.removeFirst(RouteHeader.NAME);
            }

            if (this.stayInSignalingPath()) {
                this.configureRecordRoute(requestOut, advertisedAddr);
            }

            if (route.thruGw) {
                this.configureRoutingHeaders(requestOut, route);
            }

            this.sendRequest(requestIn, requestOut, serverTransaction);
        }
    }, {
        key: 'stayInSignalingPath',
        value: function stayInSignalingPath() {
            return this.config.spec.recordRoute ? true : false;
        }
    }, {
        key: 'proxyOwnsRequest',
        value: function proxyOwnsRequest(request, localAddr, advertisedAddr) {
            var routeHeader = request.getHeader(RouteHeader.NAME);
            if (routeHeader) {
                var h = routeHeader.getAddress().getURI().getHost();
                var host = _ip_util2.default.isIp(h) ? h : Packages.java.net.InetAddress.getByName(h).getHostAddress();
                var port = routeHeader.getAddress().getURI().getPort() == -1 ? 5060 : routeHeader.getAddress().getURI().getPort();

                if (host.equals(advertisedAddr.host) && port.equals(advertisedAddr.port)) {
                    return true;
                }

                if (host.equals(localAddr.host) && port.equals(localAddr.port)) {
                    return true;
                }
            }
            return false;
        }
    }, {
        key: 'configureGeneral',
        value: function configureGeneral(request, route, advertisedAddr) {
            var transport = request.getHeader(ViaHeader.NAME).getTransport().toLowerCase();
            request.setRequestURI(route.contactURI);
            var viaHeader = this.headerFactory.createViaHeader(advertisedAddr.host, advertisedAddr.port, transport, null);
            viaHeader.setRPort();
            request.addFirst(viaHeader);
            request.removeHeader("Proxy-Authorization");
            var maxForwardsHeader = request.getHeader(MaxForwardsHeader.NAME);
            maxForwardsHeader.decrementMaxForwards();
        }
    }, {
        key: 'configureRecordRoute',
        value: function configureRecordRoute(request, advertisedAddr) {
            var proxyURI = this.addressFactory.createSipURI(null, advertisedAddr.host);
            proxyURI.setLrParam();
            proxyURI.setPort(advertisedAddr.port);
            var proxyAddress = this.addressFactory.createAddress(proxyURI);
            var recordRouteHeader = this.headerFactory.createRecordRouteHeader(proxyAddress);
            request.addHeader(recordRouteHeader);
        }
    }, {
        key: 'configureRoutingHeaders',
        value: function configureRoutingHeaders(request, route) {
            // Lower the cseq to match the original request
            if (request.getMethod().equals(Request.INVITE)) {
                var cseq = request.getHeader(CSeqHeader.NAME).getSeqNumber() - 1;
                request.getHeader(CSeqHeader.NAME).setSeqNumber(cseq);
            }
            var gwRefHeader = this.headerFactory.createHeader('X-Gateway-Ref', route.gwRef);
            var remotePartyIdHeader = this.headerFactory.createHeader('Remote-Party-ID', '<sip:' + route.did + '@' + route.gwHost + '>;screen=yes;party=calling');
            request.setHeader(gwRefHeader);
            request.setHeader(remotePartyIdHeader);
        }
    }, {
        key: 'sendRequest',
        value: function sendRequest(requestIn, requestOut, serverTransaction) {
            // Does not need a transaction
            if (requestIn.getMethod().equals(Request.ACK)) {
                return this.sipProvider.sendRequest(requestOut);
            }

            try {
                // The request must be cloned or the stack will not fork the call
                var clientTransaction = this.sipProvider.getNewClientTransaction(requestOut.clone());
                clientTransaction.sendRequest();
                this.saveContext(requestIn, requestOut, clientTransaction, serverTransaction);
            } catch (e) {
                if (e instanceof java.net.ConnectException) {
                    LOG.error('Connection refused. Please see: https://docs.oracle.com/javase/7/docs/api/java/net/ConnectException.html');
                } else if (e instanceof java.net.NoRouteToHostException) {
                    LOG.error('No route to host. Please see: https://docs.oracle.com/javase/7/docs/api/java/net/NoRouteToHostException.html');
                } else {
                    LOG.error(e);
                }
            }
        }
    }, {
        key: 'saveContext',
        value: function saveContext(requestIn, requestOut, clientTransaction, serverTransaction) {
            // Transaction context
            var context = new _context2.default();
            context.clientTransaction = clientTransaction;
            context.serverTransaction = serverTransaction;
            context.method = requestIn.getMethod();
            context.requestIn = requestIn;
            context.requestOut = requestOut;
            this.contextStorage.saveContext(context);
        }
    }, {
        key: 'getAdvertizedAddr',
        value: function getAdvertizedAddr(route, localAddr, externAddr) {
            // No egress routing has sentByAddress. They are assume to be entities outside the local network.
            if (externAddr && (route.sentByAddress == undefined || route.sentByAddress.endsWith(".invalid") || !this.ipUtil.isLocalnet(route.sentByAddress))) {

                return {
                    host: externAddr.contains(":") ? externAddr.split(":")[0] : externAddr,
                    port: externAddr.contains(":") ? externAddr.split(":")[1] : localAddr.port
                };
            }

            return { host: localAddr.host, port: localAddr.port };
        }
    }]);

    return RequestHandler;
}();

exports.default = RequestHandler;