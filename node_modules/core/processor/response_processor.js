'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author Pedro Sanders
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @since v1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _account_manager_service = require('core/account_manager_service');

var _account_manager_service2 = _interopRequireDefault(_account_manager_service);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SipFactory = Packages.javax.sip.SipFactory;
var FromHeader = Packages.javax.sip.header.FromHeader;
var ViaHeader = Packages.javax.sip.header.ViaHeader;
var ContactHeader = Packages.javax.sip.header.ContactHeader;
var CSeqHeader = Packages.javax.sip.header.CSeqHeader;
var ExpiresHeader = Packages.javax.sip.header.ExpiresHeader;
var Request = Packages.javax.sip.message.Request;
var Response = Packages.javax.sip.message.Response;
var LogManager = Packages.org.apache.logging.log4j.LogManager;
var LOG = LogManager.getLogger();

var ResponseProcessor = function () {
    function ResponseProcessor(sipProvider, locator, registry, registrar, dataAPIs, contextStorage) {
        _classCallCheck(this, ResponseProcessor);

        this.sipProvider = sipProvider;
        this.registry = registry;
        this.contextStorage = contextStorage;
        this.headerFactory = SipFactory.getInstance().createHeaderFactory();
        this.accountManagerService = new _account_manager_service2.default(dataAPIs);
    }

    _createClass(ResponseProcessor, [{
        key: 'process',
        value: function process(event) {
            var response = event.getResponse();

            // The stack takes care of this cases
            if (ResponseProcessor.isStackJob(response)) {
                return;
            }

            if (ResponseProcessor.isRegisterOk(response)) {
                if (ResponseProcessor.isBehindNat(response)) {
                    return this.reRegister(event);
                }
                this.storeInRegistry(response);
            } else if (ResponseProcessor.isRegisterNok(response)) {
                this.removeFromRegistry(response);
            }

            ResponseProcessor.mustAuthenticate(response) ? this.handleAuthChallenge(event) : this.sendResponse(event);
        }
    }, {
        key: 'storeInRegistry',
        value: function storeInRegistry(response) {
            var fromURI = response.getHeader(FromHeader.NAME).getAddress().getURI();
            var expiresHeader = response.getHeader(ExpiresHeader.NAME);
            var expires = expiresHeader != null ? expiresHeader.getExpires() : 3600;
            this.registry.storeRegistry(fromURI, expires);
        }
    }, {
        key: 'removeFromRegistry',
        value: function removeFromRegistry(response) {
            var fromURI = response.getHeader(FromHeader.NAME).getAddress().getURI();
            this.registry.removeRegistry(fromURI.toString());
        }
    }, {
        key: 'handleAuthChallenge',
        value: function handleAuthChallenge(event) {
            var authHelper = this.sipProvider.getSipStack().getAuthenticationHelper(this.accountManagerService.getAccountManager(), this.headerFactory);
            // Setting looseRouting to false will cause https://github.com/fonoster/routr/issues/18
            authHelper.handleChallenge(event.getResponse(), event.getClientTransaction(), event.getSource(), 5, true).sendRequest();
        }
    }, {
        key: 'reRegister',
        value: function reRegister(event) {
            var response = event.getResponse();
            var clientTransaction = event.getClientTransaction();
            var viaHeader = response.getHeader(ViaHeader.NAME);
            var expires = response.getHeader(ExpiresHeader.NAME).getExpires();

            LOG.debug('Routr is behind a NAT. Re-registering using Received and RPort');

            try {
                var fromURI = response.getHeader(FromHeader.NAME).getAddress().getURI();
                var gwRef = clientTransaction.getRequest().getHeader('X-Gateway-Ref').value;
                this.registry.requestChallenge(fromURI.getUser(), gwRef, fromURI.getHost(), viaHeader.getTransport().toLowerCase(), viaHeader.getReceived(), viaHeader.getRPort(), expires);
            } catch (e) {
                LOG.error(e);
            }
        }
    }, {
        key: 'sendResponse',
        value: function sendResponse(event) {
            var responseOut = event.getResponse().clone();
            responseOut.removeFirst(ViaHeader.NAME);

            if (ResponseProcessor.isInviteWithCT(event)) {
                var context = this.contextStorage.findContext(event.getClientTransaction());

                if (context != null && context.serverTransaction != null) {
                    context.serverTransaction.sendResponse(responseOut);
                } else if (responseOut.getHeader(ViaHeader.NAME) != null) {
                    this.sipProvider.sendResponse(responseOut);
                }
            } else if (responseOut.getHeader(ViaHeader.NAME) != null) {
                // Could be a BYE due to Record-Route
                // There is no more Via headers; the response was intended for the proxy.
                this.sipProvider.sendResponse(responseOut);
            }

            LOG.debug(responseOut);
        }
    }], [{
        key: 'isOk',
        value: function isOk(response) {
            return response.getStatusCode() == Response.OK;
        }
    }, {
        key: 'mustAuthenticate',
        value: function mustAuthenticate(response) {
            if (response.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED || response.getStatusCode() == Response.UNAUTHORIZED) {
                return true;
            }
            return false;
        }
    }, {
        key: 'isInvite',
        value: function isInvite(response) {
            return response.getHeader(CSeqHeader.NAME).getMethod().equals(Request.INVITE);
        }
    }, {
        key: 'isInviteOk',
        value: function isInviteOk(response) {
            return ResponseProcessor.isInvite(response) && ResponseProcessor.isOk(response);
        }
    }, {
        key: 'isInviteNok',
        value: function isInviteNok(response) {
            return ResponseProcessor.isInvite(response) && !ResponseProcessor.isOk(response);
        }
    }, {
        key: 'isStackJob',
        value: function isStackJob(response) {
            if (response.getStatusCode() == Response.TRYING || response.getStatusCode() == Response.REQUEST_TERMINATED || response.getHeader(CSeqHeader.NAME).getMethod().equals(Request.CANCEL)) {
                return true;
            }
            return false;
        }
    }, {
        key: 'isBehindNat',
        value: function isBehindNat(response) {
            var viaHeader = response.getHeader(ViaHeader.NAME);
            var contactHeader = response.getHeader(ContactHeader.NAME);
            var host = contactHeader.getAddress().getHost();
            var port = contactHeader.getAddress().getPort();
            var received = viaHeader.getReceived();
            var rPort = viaHeader.getRPort();
            return !!received && !host.equals(received) || port != rPort ? true : false;
        }
    }, {
        key: 'isRegister',
        value: function isRegister(response) {
            var cseq = response.getHeader(CSeqHeader.NAME);
            return cseq.getMethod().equals(Request.REGISTER) ? true : false;
        }
    }, {
        key: 'isRegisterOk',
        value: function isRegisterOk(response) {
            if (ResponseProcessor.isRegister(response) && ResponseProcessor.isOk(response)) {
                return true;
            }
            return false;
        }
    }, {
        key: 'isRegisterNok',
        value: function isRegisterNok(response) {
            if (!ResponseProcessor.isOk(response) && ResponseProcessor.isRegister(response)) {
                return true;
            }
            return false;
        }
    }, {
        key: 'isInviteWithCT',
        value: function isInviteWithCT(event) {
            return ResponseProcessor.isInvite(event.getResponse()) && event.getClientTransaction() != null ? true : false;
        }
    }]);

    return ResponseProcessor;
}();

exports.default = ResponseProcessor;