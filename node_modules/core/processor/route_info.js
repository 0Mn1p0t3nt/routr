'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author Pedro Sanders
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @since v1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _route_entity_type = require('core/route_entity_type');

var _routing_type = require('core/routing_type');

var _config_util = require('core/config_util');

var _config_util2 = _interopRequireDefault(_config_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ToHeader = Packages.javax.sip.header.ToHeader;
var FromHeader = Packages.javax.sip.header.FromHeader;
var StringUtils = Packages.org.apache.commons.lang3.StringUtils;

var RouteInfo = function () {
    function RouteInfo(request, dataAPIs) {
        _classCallCheck(this, RouteInfo);

        var fromHeader = request.getHeader(FromHeader.NAME);
        var toHeader = request.getHeader(ToHeader.NAME);
        var sipFactory = Packages.javax.sip.SipFactory.getInstance();
        this.config = (0, _config_util2.default)();
        this.addressFactory = sipFactory.createAddressFactory();
        this.request = request;
        this._callerUser = fromHeader.getAddress().getURI().getUser();
        this._callerHost = fromHeader.getAddress().getURI().getHost();
        this._calleeUser = toHeader.getAddress().getURI().getUser();
        this._calleeHost = toHeader.getAddress().getURI().getHost();

        // Overwrites callee info if addressInfo is present
        if (!!this.config.spec.addressInfo) {
            var callee = getCalleeFromAddressInfo(request, this.config.spec.addressInfo);
            this._calleeUser = callee.user;
            this._calleeHost = callee.host;
        }

        this.peersAPI = dataAPIs.PeersAPI;
        this.domainsAPI = dataAPIs.DomainsAPI;
        this.didsAPI = dataAPIs.DIDsAPI;
        this.agentsAPI = dataAPIs.AgentsAPI;
    }

    _createClass(RouteInfo, [{
        key: 'getCalleeFromAddressInfo',
        value: function getCalleeFromAddressInfo(request, addressInfo) {
            var callee = {};
            for (var x in addressInfo) {
                var info = addressInfo[x];
                if (!!request.getHeader(info)) {
                    var v = request.getHeader(info).getValue();
                    if (/sips?:.*@.*/.test(v)) {
                        var calleeURI = this.addressFactory.createURI(v);
                        callee.user = calleeURI.getUser();
                        callee.host = calleeURI.getHost();
                        break;
                    }
                    LOG.error('Invalid address: ' + v);
                }
            }
            return callee;
        }
    }, {
        key: 'getRoutingType',
        value: function getRoutingType() {
            var routingType = _routing_type.RoutingType.UNKNOWN;
            var callerType = this.getCallerType();
            var calleetype = this.getCalleeType();
            var belongToSameDomain = this.isSameDomain();

            if (callerType == _route_entity_type.RouteEntityType.AGENT && calleetype == _route_entity_type.RouteEntityType.AGENT && belongToSameDomain) routingType = _routing_type.RoutingType.INTRA_DOMAIN_ROUTING;
            if (callerType == _route_entity_type.RouteEntityType.AGENT && calleetype == _route_entity_type.RouteEntityType.PEER && belongToSameDomain) routingType = _routing_type.RoutingType.INTRA_DOMAIN_ROUTING;

            if (callerType == _route_entity_type.RouteEntityType.AGENT && calleetype == _route_entity_type.RouteEntityType.AGENT && !belongToSameDomain) routingType = _routing_type.RoutingType.INTER_DOMAIN_ROUTING;
            if (callerType == _route_entity_type.RouteEntityType.AGENT && calleetype == _route_entity_type.RouteEntityType.PEER && !belongToSameDomain) routingType = _routing_type.RoutingType.INTER_DOMAIN_ROUTING;
            if (callerType == _route_entity_type.RouteEntityType.AGENT && calleetype == _route_entity_type.RouteEntityType.THRU_GW) routingType = _routing_type.RoutingType.DOMAIN_EGRESS_ROUTING;

            if (callerType == _route_entity_type.RouteEntityType.PEER && calleetype == _route_entity_type.RouteEntityType.AGENT && !belongToSameDomain) routingType = _routing_type.RoutingType.INTER_DOMAIN_ROUTING;
            if (callerType == _route_entity_type.RouteEntityType.PEER && calleetype == _route_entity_type.RouteEntityType.AGENT && belongToSameDomain) routingType = _routing_type.RoutingType.INTRA_DOMAIN_ROUTING;
            if (callerType == _route_entity_type.RouteEntityType.PEER && this.getCalleeType() == _route_entity_type.RouteEntityType.THRU_GW) routingType = _routing_type.RoutingType.PEER_EGRESS_ROUTING;

            if (callerType == _route_entity_type.RouteEntityType.THRU_GW && calleetype == _route_entity_type.RouteEntityType.DID) routingType = _routing_type.RoutingType.DOMAIN_INGRESS_ROUTING;

            // This is consider PEER_EGRESS_ROUTING because peers are the only one allow to overwrite the FromHeader.
            if (callerType == _route_entity_type.RouteEntityType.DID && this.getCalleeType() == _route_entity_type.RouteEntityType.THRU_GW) routingType = _routing_type.RoutingType.PEER_EGRESS_ROUTING;

            return routingType;
        }
    }, {
        key: 'getRouteEntityType',
        value: function getRouteEntityType(domain, entity) {
            var entityType = _route_entity_type.RouteEntityType.THRU_GW;

            if (this.peersAPI.peerExist(entity)) {
                entityType = _route_entity_type.RouteEntityType.PEER;
            }

            if (this.agentsAPI.agentExist(domain, entity)) {
                entityType = _route_entity_type.RouteEntityType.AGENT;
            }

            if (StringUtils.isNumeric(this.callerUser)) {
                var telUrl = this.addressFactory.createTelURL(entity);
                if (this.didsAPI.didExist(telUrl)) {
                    entityType = _route_entity_type.RouteEntityType.DID;
                }
            }

            if (this.agentsAPI.agentExist(domain, entity)) {
                entityType = _route_entity_type.RouteEntityType.AGENT;
            }

            return entityType;
        }
    }, {
        key: 'getCallerType',
        value: function getCallerType() {
            return this.getRouteEntityType(this.callerDomain, this.callerUser);
        }
    }, {
        key: 'getCalleeType',
        value: function getCalleeType() {
            return this.getRouteEntityType(this.calleeDomain, this.calleeUser);
        }
    }, {
        key: 'isSameDomain',
        value: function isSameDomain() {
            return this.callerDomain.equals(this.calleeDomain);
        }
    }, {
        key: 'callerUser',
        get: function get() {
            return this._callerUser;
        }
    }, {
        key: 'callerDomain',
        get: function get() {
            return this._callerHost;
        }
    }, {
        key: 'calleeUser',
        get: function get() {
            return this._calleeUser;
        }
    }, {
        key: 'calleeDomain',
        get: function get() {
            return this._calleeHost;
        }
    }]);

    return RouteInfo;
}();

exports.default = RouteInfo;