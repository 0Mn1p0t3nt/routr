'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Stores information on sip devices currently registered in the server.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This implementation won't scale to thousands of devices.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author Pedro Sanders
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @since v1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _utils = require('core/utils');

var _utils2 = _interopRequireDefault(_utils);

var _utils3 = require('location/utils');

var _utils4 = _interopRequireDefault(_utils3);

var _obj_util = require('utils/obj_util');

var _obj_util2 = _interopRequireDefault(_obj_util);

var _status = require('core/status');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var HashMap = Packages.java.util.HashMap;
var LogManager = Packages.org.apache.logging.log4j.LogManager;
var LOG = LogManager.getLogger();
var SipFactory = Packages.javax.sip.SipFactory;

/**
 * NOTE #1: Notice that addressOfRecord.toString !eq to LocatorUtils.aorAsString(addressOfRecord). This is important to ensure
 * the location of the devices regardless of any additional parameters that they may have.
 */

var Locator = function () {
    function Locator(dataAPIs) {
        var checkExpiresTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

        _classCallCheck(this, Locator);

        this.checkExpiresTime = checkExpiresTime;
        this.db = new HashMap();
        this.didsAPI = dataAPIs.DIDsAPI;
        this.domainsAPI = dataAPIs.DomainsAPI;
        this.gatewaysAPI = dataAPIs.GatewaysAPI;
        this.addressFactory = SipFactory.getInstance().createAddressFactory();
    }

    _createClass(Locator, [{
        key: 'addEndpoint',
        value: function addEndpoint(addressOfRecord, route) {
            var response = this.findEndpoint(addressOfRecord);
            var routes = void 0;

            if (response.status == _status.Status.OK) {
                // Only use if is a "local" route
                routes = response.result.thruGw == false ? response.result : [];
            } else {
                // Did not found any round at all
                routes = [];
            }

            routes.push(route);

            // See NOTE #1
            this.db.put(_utils4.default.aorAsString(addressOfRecord), routes);
        }

        // See NOTE #1

    }, {
        key: 'removeEndpoint',
        value: function removeEndpoint(addressOfRecord, contactURI) {
            var aor = _utils4.default.aorAsString(addressOfRecord);
            // Remove all bindings
            if (contactURI == null) {
                return this.db.remove(aor);
            }
            // Not using aorAsString because we need to consider the port, etc.
            this.db.get(aor).remove(contactURI.toString());

            if (this.db.get(aor).isEmpty()) this.db.remove(aor);
        }
    }, {
        key: 'findEndpoint',
        value: function findEndpoint(addressOfRecord) {
            if (addressOfRecord instanceof Packages.javax.sip.address.TelURL) {
                return this.findEndpointByTelUrl(addressOfRecord);
            }
            return this.findEndpointBySipURI(addressOfRecord);
        }

        /**
         * DIDs required an "aorLink" enter the network
         */

    }, {
        key: 'findEndpointByTelUrl',
        value: function findEndpointByTelUrl(addressOfRecord) {
            var response = this.didsAPI.getDIDByTelUrl(addressOfRecord);
            if (response.status == _status.Status.OK) {
                var did = response.result;
                var route = this.db.get(_utils4.default.aorAsString(did.spec.location.aorLink));

                if (route != null) {
                    return _utils2.default.buildResponse(_status.Status.OK, route);
                }

                return _utils2.default.buildResponse(_status.Status.NOT_FOUND, 'No route for aorLink: ' + did.spec.location.aorLink);
            }
            return _utils2.default.buildResponse(_status.Status.NOT_FOUND);
        }
    }, {
        key: 'findEndpointBySipURI',
        value: function findEndpointBySipURI(addressOfRecord) {
            // First just look into the 'db'
            var routes = this.db.get(_utils4.default.aorAsString(addressOfRecord));

            if (routes != null) {
                return _utils2.default.buildResponse(_status.Status.OK, routes);
            }

            // Check peer's route by host
            var response = this.getPeerRouteByHost(addressOfRecord);

            if (response.status == _status.Status.OK) {
                return response;
            }

            // Then search for a DID
            try {
                response = this.findEndpointForDID(addressOfRecord);
                if (response.status == _status.Status.OK) {
                    return response;
                }
            } catch (e) {}
            //noop


            // Endpoint can only be reach thru a gateway
            response = this.getEgressRouteForAOR(addressOfRecord);
            return response.status == _status.Status.OK ? response : _utils2.default.buildResponse(_status.Status.NOT_FOUND);
        }
    }, {
        key: 'findEndpointForDID',
        value: function findEndpointForDID(addressOfRecord) {
            var telUrl = this.addressFactory.createTelURL(addressOfRecord.getUser());
            var response = this.didsAPI.getDIDByTelUrl(telUrl);
            if (response.status == _status.Status.OK) {
                var did = response.result;
                var route = this.db.get(_utils4.default.aorAsString(did.spec.location.aorLink));
                if (route != null) {
                    return _utils2.default.buildResponse(_status.Status.OK, route);
                }
            }
            return _utils2.default.buildResponse(_status.Status.NOT_FOUND);
        }
    }, {
        key: 'getPeerRouteByHost',
        value: function getPeerRouteByHost(addressOfRecord) {
            var aors = this.db.keySet().iterator();

            while (aors.hasNext()) {
                var key = aors.next();
                var routes = this.db.get(key);
                for (var x in routes) {
                    var h1 = routes[x].contactURI.getHost().toString();
                    var h2 = addressOfRecord.getHost().toString();
                    var p1 = routes[x].contactURI.getPort() == -1 ? 5060 : routes[x].contactURI.getPort();
                    var p2 = addressOfRecord.getPort() == -1 ? 5060 : addressOfRecord.getPort();
                    if (h1.equals(h2) && p1 == p2) {
                        return _utils2.default.buildResponse(_status.Status.OK, routes);
                    }
                }
            }

            return _utils2.default.buildResponse(_status.Status.NOT_FOUND);
        }
    }, {
        key: 'getEgressRouteForAOR',
        value: function getEgressRouteForAOR(addressOfRecord) {
            var _this = this;

            if (!(addressOfRecord instanceof Packages.javax.sip.address.SipURI)) throw 'AOR must be an instance of javax.sip.address.SipURI';

            var response = this.domainsAPI.getDomains();
            var route = void 0;

            if (response.status == _status.Status.OK) {
                response.result.forEach(function (domain) {
                    var r = _this.getEgressRouteForDomain(domain, addressOfRecord);
                    if (r.status == _status.Status.OK) {
                        route = r.result;
                    }
                });
            }

            return route ? _utils2.default.buildResponse(_status.Status.OK, route) : _utils2.default.buildResponse(_status.Status.OK, _utils4.default.buildForwardRoute(addressOfRecord));
        }
    }, {
        key: 'getEgressRouteForDomain',
        value: function getEgressRouteForDomain(domain, addressOfRecord) {
            if ((0, _obj_util2.default)(domain.spec.context.egressPolicy) == false) {
                // Get DID and Gateway info
                var response = this.didsAPI.getDID(domain.spec.context.egressPolicy.didRef);
                var did = response.result;

                if (response.status == _status.Status.OK) {
                    response = this.gatewaysAPI.getGateway(did.metadata.gwRef);

                    if (response.status == _status.Status.OK) {
                        var gateway = response.result;
                        var pattern = 'sip:' + domain.spec.context.egressPolicy.rule + '@' + domain.spec.context.domainUri;

                        if (new RegExp(pattern).test(addressOfRecord.toString())) {
                            var contactURI = this.addressFactory.createSipURI(addressOfRecord.getUser(), gateway.spec.host);
                            contactURI.setSecure(addressOfRecord.isSecure());
                            var route = _utils4.default.buildEgressRoute(contactURI, gateway, did, domain);
                            return _utils2.default.buildResponse(_status.Status.OK, [route]);
                        }
                    }
                }
                return _utils2.default.buildResponse(_status.Status.NOT_FOUND);
            }
            return _utils2.default.buildResponse(_status.Status.BAD_REQUEST, 'No egressPolicy found');
        }
    }, {
        key: 'getEgressRouteForPeer',
        value: function getEgressRouteForPeer(addressOfRecord, didRef) {
            var response = this.didsAPI.getDID(didRef);
            var route = void 0;

            if (response.status == _status.Status.OK) {
                var did = response.result;
                response = this.gatewaysAPI.getGateway(did.metadata.gwRef);

                if (response.status == _status.Status.OK) {
                    var gateway = response.result;
                    var contactURI = this.addressFactory.createSipURI(addressOfRecord.getUser(), gateway.spec.host);
                    route = _utils4.default.buildEgressRoute(contactURI, gateway, did);
                }
            }

            return route ? _utils2.default.buildResponse(_status.Status.OK, route) : _utils2.default.buildResponse(_status.Status.NOT_FOUND);
        }
    }, {
        key: 'listAsJSON',
        value: function listAsJSON(domainUri) {
            var s = [];
            var aors = this.db.keySet().iterator();

            while (aors.hasNext()) {
                var key = aors.next();
                var routes = this.db.get(key);
                var contactInfo = '';

                if (routes.length > 0) {
                    var rObj = routes[0];
                    var r = rObj.contactURI + ';nat=' + rObj.nat + ';expires=' + rObj.expires;

                    if (routes.length > 1) r = r + ' [...]';
                    contactInfo = contactInfo + r;
                }

                var tmp = { 'addressOfRecord': key, 'contactInfo': contactInfo };
                s.push(tmp);
            }

            return s;
        }
    }, {
        key: 'start',
        value: function start() {
            LOG.info('Starting Location service');
            var locDB = this.db;

            var unbindExpiredTask = new java.util.TimerTask({
                run: function run() {
                    var e = locDB.values().iterator();

                    while (e.hasNext()) {
                        var routes = e.next();

                        for (var x in routes) {
                            var route = routes[x];
                            var elapsed = (Date.now() - route.registeredOn) / 1000;
                            if (route.expires - elapsed <= 0) {
                                routes.splice(x, 1);
                            }

                            if (routes.length == 0) {
                                e.remove();
                            }
                        }
                    }
                }
            });

            new java.util.Timer().schedule(unbindExpiredTask, 5000, this.checkExpiresTime * 60 * 1000);
        }
    }, {
        key: 'stop',
        value: function stop() {
            // ??
        }
    }]);

    return Locator;
}();

exports.default = Locator;