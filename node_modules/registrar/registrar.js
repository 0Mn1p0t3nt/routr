'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author Pedro Sanders
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @since v1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _auth_helper = require('utils/auth_helper');

var _auth_helper2 = _interopRequireDefault(_auth_helper);

var _status = require('core/status');

var _obj_util = require('utils/obj_util');

var _obj_util2 = _interopRequireDefault(_obj_util);

var _config_util = require('core/config_util.js');

var _config_util2 = _interopRequireDefault(_config_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ViaHeader = Packages.javax.sip.header.ViaHeader;
var ContactHeader = Packages.javax.sip.header.ContactHeader;
var FromHeader = Packages.javax.sip.header.FromHeader;
var ExpiresHeader = Packages.javax.sip.header.ExpiresHeader;
var AuthorizationHeader = Packages.javax.sip.header.AuthorizationHeader;
var SipFactory = Packages.javax.sip.SipFactory;

var Registrar = function () {
    function Registrar(locator, dataAPIs) {
        _classCallCheck(this, Registrar);

        this.locator = locator;
        this.peersAPI = dataAPIs.PeersAPI;
        this.agentsAPI = dataAPIs.AgentsAPI;
        this.addressFactory = SipFactory.getInstance().createAddressFactory();
    }

    _createClass(Registrar, [{
        key: 'register',
        value: function register(r) {
            // For some reason this references the parent object
            // to avoid I just clone it!
            var request = r.clone();
            var authHeader = request.getHeader(AuthorizationHeader.NAME);
            var fromHeader = request.getHeader(FromHeader.NAME);
            var fromURI = fromHeader.getAddress().getURI();
            var host = fromURI.getHost();

            // Get user from db or file
            var user = this.getUser(authHeader.getUsername(), host);
            var aHeaderJson = Registrar.buildHeader(user, authHeader);

            if (new _auth_helper2.default().calcFromHeader(aHeaderJson).equals(authHeader.getResponse())) {
                this.addEndpoint(user, host, request);
                return true;
            }
            return false;
        }
    }, {
        key: 'hasDomain',
        value: function hasDomain(user, domain) {
            if (user.spec.domains == null || user.spec.domains.length == 0) return false;
            var result = false;
            user.spec.domains.forEach(function (d) {
                if (domain === d) result = true;
            });
            return result;
        }
    }, {
        key: 'addEndpoint',
        value: function addEndpoint(user, host, request) {
            var _this = this;

            var contactHeader = request.getHeader(ContactHeader.NAME);
            var contactURI = contactHeader.getAddress().getURI();
            var viaHeader = request.getHeader(ViaHeader.NAME);
            var route = Registrar.buildRoute(user, viaHeader, contactURI, Registrar.getExpires(request));
            var addressOfRecord = void 0;

            if (user.kind.equalsIgnoreCase('peer')) {
                var peerHost = (0, _obj_util2.default)(user.spec.device) ? host : user.spec.device;
                addressOfRecord = this.addressFactory.createSipURI(user.spec.credentials.username, peerHost);
                addressOfRecord.setSecure(contactURI.isSecure());
            } else {
                user.spec.domains.forEach(function (domain) {
                    addressOfRecord = _this.addressFactory.createSipURI(user.spec.credentials.username, domain);
                    addressOfRecord.setSecure(contactURI.isSecure());
                });
            }

            this.locator.addEndpoint(addressOfRecord, route);
        }
    }, {
        key: 'getUser',
        value: function getUser(username, host) {
            var user = void 0;
            var response = this.peersAPI.getPeerByUsername(username);

            if (response.status == _status.Status.OK) {
                user = response.result;
            } else {
                // Then lets check agents
                response = this.agentsAPI.getAgent(host, username);

                if (response.status == _status.Status.OK) {
                    user = response.result;
                }
            }

            if (user == null) {
                throw 'Could not find agent or peer \'' + username + '\'';
            }

            return user;
        }
    }], [{
        key: 'getNonceCount',
        value: function getNonceCount(d) {
            var h = Packages.java.lang.Integer.toHexString(d);
            var cSize = 8 - h.toString().length();
            var nc = '';
            var cnt = 0;

            while (cSize > cnt) {
                nc += '0';
                cnt++;
            }

            return nc + h;
        }
    }, {
        key: 'buildRoute',
        value: function buildRoute(user, viaHeader, contactURI, expires) {
            // Detect NAT
            var nat = viaHeader.getHost() + viaHeader.getPort() != viaHeader.getReceived() + viaHeader.getParameter('rport');
            return {
                isLinkAOR: false,
                thruGw: false,
                sentByAddress: viaHeader.getHost(),
                sentByPort: viaHeader.getPort() == -1 ? 5060 : viaHeader.getPort(),
                received: viaHeader.getReceived(),
                rport: viaHeader.getParameter('rport'),
                contactURI: Registrar.getUpdatedContactURI(user, viaHeader, contactURI),
                registeredOn: Date.now(),
                expires: expires,
                nat: nat
            };
        }
    }, {
        key: 'getUpdatedContactURI',
        value: function getUpdatedContactURI(user, viaHeader, contactURI) {
            if (user.kind.equalsIgnoreCase('peer') && !(0, _obj_util2.default)(user.spec.contactAddr)) {
                if (user.spec.contactAddr.contains(":")) {
                    contactURI.setHost(user.spec.contactAddr.split(":")[0]);
                    contactURI.setPort(user.spec.contactAddr.split(":")[1]);
                } else {
                    contactURI.setHost(user.spec.contactAddr);
                }
            } else if (Registrar.useInternalInterface(viaHeader)) {
                if (viaHeader.getReceived() != null) {
                    contactURI.setHost(viaHeader.getReceived());
                }

                if (viaHeader.getParameter('rport') != null) {
                    contactURI.setPort(viaHeader.getParameter('rport'));
                }
            }
            return contactURI;
        }
    }, {
        key: 'useInternalInterface',
        value: function useInternalInterface(viaHeader) {
            if ((0, _config_util2.default)().spec.registrarIntf.equalsIgnoreCase('Internal')) {
                return true;
            }
            return viaHeader.getTransport().equalsIgnoreCase('udp') ? true : false;
        }
    }, {
        key: 'buildHeader',
        value: function buildHeader(user, authHeader) {
            return {
                username: user.spec.credentials.username,
                secret: user.spec.credentials.secret,
                realm: authHeader.getRealm(),
                nonce: authHeader.getNonce(),
                // For some weird reason the interface value is an int while the value original value is a string
                nc: Registrar.getNonceCount(authHeader.getNonceCount()),
                cnonce: authHeader.getCNonce(),
                uri: authHeader.getURI().toString(),
                method: 'REGISTER',
                qop: authHeader.getQop()
            };
        }
    }, {
        key: 'getExpires',
        value: function getExpires(request) {
            var contactHeader = request.getHeader(ContactHeader.NAME);
            return request.getHeader(ExpiresHeader.NAME) ? request.getHeader(ExpiresHeader.NAME).getExpires() : contactHeader.getExpires();
        }
    }]);

    return Registrar;
}();

exports.default = Registrar;