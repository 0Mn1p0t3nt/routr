'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author Pedro Sanders
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @since v1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _config_util = require('core/config_util');

var _config_util2 = _interopRequireDefault(_config_util);

var _status = require('core/status');

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SipFactory = Packages.javax.sip.SipFactory;
var SipUtils = Packages.gov.nist.javax.sip.Utils;
var Request = Packages.javax.sip.message.Request;
var InetAddress = Packages.java.net.InetAddress;
var HashMap = Packages.java.util.HashMap;
var LogManager = Packages.org.apache.logging.log4j.LogManager;
var LOG = LogManager.getLogger();

var cseq = 0;

var Registry = function () {
    function Registry(sipProvider, dataAPIs) {
        _classCallCheck(this, Registry);

        this.dataAPIs = dataAPIs.GatewaysAPI;
        this.gatewaysAPI = dataAPIs.GatewaysAPI;
        this.checkExpiresTime = .5;
        this.sipProvider = sipProvider;
        this.config = (0, _config_util2.default)();
        this.messageFactory = SipFactory.getInstance().createMessageFactory();
        this.headerFactory = SipFactory.getInstance().createHeaderFactory();
        this.addressFactory = SipFactory.getInstance().createAddressFactory();
        this.userAgent = new java.util.ArrayList();
        this.userAgent.add(this.config.metadata.userAgent);
        this.registry = new HashMap();
    }

    _createClass(Registry, [{
        key: 'getLPAddress',
        value: function getLPAddress(transport, received, rport) {
            try {
                var lp = this.sipProvider.getListeningPoint(transport);
                var host = this.config.spec.externAddr ? this.config.spec.externAddr : lp.getIPAddress();
                var port = rport ? rport : lp.getPort();
                return received ? { host: received, port: port } : { host: host, port: port };
            } catch (e) {
                LOG.error("Transport '" + transport + "' not found in configs => .spec.transport.[*]");
                return;
            }
        }
    }, {
        key: 'requestChallenge',
        value: function requestChallenge(username, gwRef, gwHost, transport, received, rport, expires) {
            var contactAddr = this.getLPAddress(transport, received, rport);
            var viaAddr = this.getLPAddress(transport);
            var request = this.messageFactory.createRequest('REGISTER sip:' + gwHost + ' SIP/2.0\r\n\r\n');
            var fromAddress = this.addressFactory.createAddress('sip:' + username + '@' + gwHost);
            var contactAddress = this.addressFactory.createAddress('sip:' + username + '@' + contactAddr.host + ':' + contactAddr.port);
            var viaHeader = this.headerFactory.createViaHeader(viaAddr.host, viaAddr.port, transport, null);
            var headers = [];

            viaHeader.setRPort();
            headers.push(viaHeader);
            headers.push(this.sipProvider.getNewCallId());
            headers.push(this.headerFactory.createExpiresHeader(expires));
            headers.push(this.headerFactory.createMaxForwardsHeader(70));
            headers.push(this.headerFactory.createCSeqHeader(cseq++, Request.REGISTER));
            headers.push(this.headerFactory.createFromHeader(fromAddress, new SipUtils().generateTag()));
            headers.push(this.headerFactory.createToHeader(fromAddress, null));
            headers.push(this.headerFactory.createContactHeader(contactAddress));
            headers.push(this.headerFactory.createUserAgentHeader(this.userAgent));
            headers.push(this.headerFactory.createAllowHeader('INVITE'));
            headers.push(this.headerFactory.createAllowHeader('ACK'));
            headers.push(this.headerFactory.createAllowHeader('BYE'));
            headers.push(this.headerFactory.createAllowHeader('CANCEL'));
            headers.push(this.headerFactory.createAllowHeader('REGISTER'));
            headers.push(this.headerFactory.createAllowHeader('OPTIONS'));
            headers.push(this.headerFactory.createHeader('X-Gateway-Ref', gwRef));
            headers.forEach(function (header) {
                return request.addHeader(header);
            });
            this.sendRequest(request, gwHost);
        }
    }, {
        key: 'sendRequest',
        value: function sendRequest(request, gwHost) {
            try {
                var clientTransaction = this.sipProvider.getNewClientTransaction(request);
                clientTransaction.sendRequest();
            } catch (e) {
                this.handleChallengeException(e, gwHost);
            }
            LOG.debug(request);
        }
    }, {
        key: 'handleChallengeException',
        value: function handleChallengeException(e, gwHost) {
            this.registry.remove(gwHost);
            if (e instanceof javax.sip.TransactionUnavailableException || e instanceof javax.sip.SipException) {
                LOG.warn('Unable to register with Gateway -> ' + gwHost + '. (Verify your network status)');
            } else {
                LOG.warn(e);
            }
        }
    }, {
        key: 'storeRegistry',
        value: function storeRegistry(gwURI, expires) {
            // Re-register before actual time expiration
            var actualExpires = expires - 2 * 60 * this.checkExpiresTime;

            var reg = {
                username: gwURI.getUser(),
                host: gwURI.getHost(),
                ip: InetAddress.getByName(gwURI.getHost()).getHostAddress(),
                expires: actualExpires,
                registeredOn: Date.now(),
                regOnFormatted: (0, _moment2.default)(new Date(Date.now())).fromNow()
            };

            this.registry.put(gwURI.toString(), reg);
        }
    }, {
        key: 'removeRegistry',
        value: function removeRegistry(gwURIStr) {
            this.registry.remove(gwURIStr);
        }
    }, {
        key: 'listAsJSON',
        value: function listAsJSON() {
            var s = [];
            var iterator = this.registry.values().iterator();

            while (iterator.hasNext()) {
                var reg = iterator.next();
                s.push(reg);
            }

            return s;
        }
    }, {
        key: 'isExpired',
        value: function isExpired(gwURIStr) {
            var reg = this.registry.get(gwURIStr);

            if (reg == null) {
                return true;
            }

            var elapsed = (Date.now() - reg.registeredOn) / 1000;
            return reg.expires - elapsed <= 0 ? true : false;
        }
    }, {
        key: 'start',
        value: function start() {
            LOG.info('Starting Registry service');
            var gatewaysAPI = this.gatewaysAPI;
            var myRegistry = this;

            var registerTask = new java.util.TimerTask({
                run: function run() {
                    var response = gatewaysAPI.getGateways();

                    if (response.status == _status.Status.OK) {
                        response.result.forEach(function (gateway) {
                            var gwURIStr = 'sip:' + gateway.spec.credentials.username + '@' + gateway.spec.host;
                            var expires = gateway.spec.expires ? gateway.spec.expires : 3600;
                            if (myRegistry.isExpired(gwURIStr)) {
                                LOG.debug('Register with ' + gateway.metadata.name + ' using ' + gateway.spec.credentials.username + '@' + gateway.spec.host);
                                myRegistry.requestChallenge(gateway.spec.credentials.username, gateway.metadata.ref, gateway.spec.host, gateway.spec.transport, null, null, expires);
                            }

                            var registries = gateway.spec.registries;

                            if (registries != undefined) {
                                registries.forEach(function (h) {
                                    if (myRegistry.isExpired(gwURIStr)) {
                                        LOG.debug('Register with ' + gateway.metadata.name + ' using ' + gateway.spec.credentials.username + '@' + h);
                                        myRegistry.requestChallenge(gateway.spec.credentials.username, gateway.metadata.ref, h, gateway.spec.transport, null, null, expires);
                                    }
                                });
                            }
                        });
                    }
                }
            });

            new java.util.Timer().schedule(registerTask, 10000, this.checkExpiresTime * 60 * 1000);
        }
    }, {
        key: 'stop',
        value: function stop() {
            // ??
        }
    }]);

    return Registry;
}();

exports.default = Registry;